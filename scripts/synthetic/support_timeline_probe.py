#!/usr/bin/env python3
"""Synthetic timeline probe for the support service.

This script creates a throwaway support ticket, requests the hydrated timeline,
validates basic invariants, and reports latency so it can be wired into a
synthetic monitoring job or CI smoke test.
"""

from __future__ import annotations

import argparse
import asyncio
import json
import os
import sys
import time
from datetime import datetime, timezone
from typing import Any
from uuid import uuid4

import httpx


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Synthetic probe for support timeline aggregation")
    parser.add_argument(
        "--base-url",
        default=os.getenv("SUPPORT_BASE_URL", "http://localhost:8000"),
        help="Base URL for the support service (default: %(default)s or SUPPORT_BASE_URL)",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=float(os.getenv("SUPPORT_PROBE_TIMEOUT", "5")),
        help="HTTP timeout in seconds (default: %(default)s or SUPPORT_PROBE_TIMEOUT)",
    )
    parser.add_argument(
        "--threshold-ms",
        type=float,
        default=float(os.getenv("SUPPORT_PROBE_THRESHOLD_MS", "1500")),
        help="Maximum acceptable timeline latency in milliseconds (default: %(default)s or SUPPORT_PROBE_THRESHOLD_MS)",
    )
    parser.add_argument(
        "--cleanup",
        action=argparse.BooleanOptionalAction,
        default=True,
        help="Attempt to close the synthetic ticket after validation (default: True)",
    )
    return parser.parse_args()


async def _create_ticket(client: httpx.AsyncClient, base_url: str) -> dict[str, Any]:
    ticket_payload = {
        "subject": f"Synthetic timeline probe {uuid4().hex[:8]}",
        "description": "Synthetic monitoring ticket generated by support_timeline_probe.",
        "customerId": "synthetic-monitoring",
        "channel": "monitoring",
        "priority": "low",
        "context": [
            {
                "type": "order",
                "orderId": 999999,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }
        ],
        "initialMessage": {
            "authorType": "customer",
            "message": "Synthetic timeline probe handshake.",
        },
    }
    response = await client.post(f"{base_url}/support/cases", json=ticket_payload)
    response.raise_for_status()
    return response.json()


async def _fetch_timeline(
    client: httpx.AsyncClient,
    base_url: str,
    ticket_id: str,
) -> tuple[dict[str, Any], float]:
    start = time.perf_counter()
    response = await client.get(
        f"{base_url}/support/cases/{ticket_id}",
        params={"includeTimeline": "true"},
    )
    response.raise_for_status()
    duration_ms = (time.perf_counter() - start) * 1000
    return response.json(), duration_ms


async def _close_ticket(
    client: httpx.AsyncClient,
    base_url: str,
    ticket_id: str,
) -> None:
    try:
        response = await client.post(
            f"{base_url}/support/cases/{ticket_id}/close",
            json={"message": "Synthetic probe auto-closure", "authorType": "agent"},
        )
        response.raise_for_status()
    except Exception:  # pragma: no cover - best effort cleanup
        pass


async def run_probe() -> int:
    args = parse_args()
    async with httpx.AsyncClient(timeout=args.timeout) as client:
        ticket = await _create_ticket(client, args.base_url)
        ticket_id = ticket["id"]
        timeline_payload, latency_ms = await _fetch_timeline(client, args.base_url, ticket_id)

        timeline_entries = timeline_payload.get("timeline", [])
        messages = timeline_payload.get("messages", [])
        validation_errors: list[str] = []

        if latency_ms > args.threshold_ms:
            validation_errors.append(
                f"timeline latency {latency_ms:.1f}ms exceeds threshold {args.threshold_ms:.1f}ms"
            )

        if not any(entry.get("type") == "conversation" for entry in timeline_entries):
            validation_errors.append("timeline entries missing conversation event")

        if not messages:
            validation_errors.append("no messages returned for synthetic ticket")

        result = {
            "ticket_id": ticket_id,
            "timeline_entries": len(timeline_entries),
            "messages": len(messages),
            "latency_ms": latency_ms,
            "threshold_ms": args.threshold_ms,
            "errors": validation_errors,
        }

        if args.cleanup:
            await _close_ticket(client, args.base_url, ticket_id)

    print(json.dumps(result, indent=2, sort_keys=True))
    if validation_errors:
        return 2
    return 0


def main() -> None:
    try:
        exit_code = asyncio.run(run_probe())
    except httpx.RequestError as exc:
        print(json.dumps({"error": f"HTTP request failed: {exc}"}), file=sys.stderr)
        exit_code = 3
    except Exception as exc:  # pragma: no cover - unexpected failure surface
        print(json.dumps({"error": str(exc)}), file=sys.stderr)
        exit_code = 4
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
